import * as i0 from '@angular/core';
import { InjectionToken, inject, effect, untracked, Injectable, runInInjectionContext, signal } from '@angular/core';
import { toSignal } from '@angular/core/rxjs-interop';
import { Router, ActivatedRoute } from '@angular/router';
import { assertInjector } from 'ngxtension/assert-injector';
import { createNotifier } from 'ngxtension/create-notifier';
import { explicitEffect } from 'ngxtension/explicit-effect';
import { distinctUntilKeyChanged, map } from 'rxjs';

const defaultConfig = {
    queryParamsHandling: 'merge',
};
const _LINKED_QUERY_PARAM_CONFIG_TOKEN = new InjectionToken('LinkedQueryParamConfig', {
    providedIn: 'root',
    factory: () => defaultConfig,
});
/*
 * This function allows users to override the default behavior of the `linkedQueryParam` navigation extras per component.
 *
 * @example
 * ```ts
 * @Component({
 *   providers: [
 *     provideLinkedQueryParamConfig({ preserveFragment: true })
 *   ]
 * })
 * export class MyComponent {
 *   // No matter which query param changes, the `preserveFragment` option
 *   // will be set to `true` for all the `linkedQueryParam` functions in this component.
 *   readonly searchQuery = linkedQueryParam('searchQuery');
 *   readonly page = linkedQueryParam('page');
 * }
 * ```
 *
 * As always, you can override this behavior on a per-function basis by passing the navigation extras to the `linkedQueryParam` function.
 *
 */
function provideLinkedQueryParamConfig(config) {
    return {
        provide: _LINKED_QUERY_PARAM_CONFIG_TOKEN,
        useValue: config,
    };
}
/**
 * Service to coalesce multiple navigation calls into a single navigation event.
 */
class LinkedQueryParamGlobalHandler {
    constructor() {
        this._router = inject(Router);
        /**
         * @internal
         * The current query params that will be set on the next navigation event.
         */
        this._currentKeys = {};
        /**
         * @internal
         * The navigation extras that will be used on the next navigation event.
         */
        this._navigationExtras = {};
        /**
         * @internal
         * The notifier that will be used to schedule the navigation event.
         */
        this._schedulerNotifier = createNotifier();
        effect(() => {
            // listen to the scheduler notifier to schedule the navigation event
            // we wrap the listen in a condition (listen() default value is 0) in order to not schedule
            // the first navigation event by default, because only changes should trigger it
            if (this._schedulerNotifier.listen()) {
                // we need to untrack the navigation call in order to not register any other signal as a dependency
                untracked(() => void this.navigate());
            }
        });
    }
    /**
     * Schedules the navigation event.
     */
    scheduleNavigation() {
        this._schedulerNotifier.notify();
    }
    /**
     * Sets the value of a query param.
     * This will be used on the next navigation event.
     */
    setParamKeyValue(key, value) {
        this._currentKeys[key] = value;
    }
    /**
     * Sets the navigation extras that will be used on the next navigation event.
     */
    setCurrentNavigationExtras(config = {}) {
        const { queryParamsHandling, onSameUrlNavigation, replaceUrl, skipLocationChange, preserveFragment, } = config;
        if (queryParamsHandling || queryParamsHandling === '') {
            this._navigationExtras.queryParamsHandling = queryParamsHandling;
        }
        if (onSameUrlNavigation) {
            this._navigationExtras.onSameUrlNavigation = onSameUrlNavigation;
        }
        if (replaceUrl) {
            this._navigationExtras.replaceUrl = replaceUrl;
        }
        if (skipLocationChange) {
            this._navigationExtras.skipLocationChange = skipLocationChange;
        }
        if (preserveFragment) {
            this._navigationExtras.preserveFragment = preserveFragment;
        }
    }
    /**
     * Navigates to the current URL with the accumulated query parameters and navigation extras.
     * Cleans up the current keys and navigation extras after the navigation.
     */
    navigate() {
        return this._router
            .navigate([], {
            queryParams: this._currentKeys,
            ...this._navigationExtras, // override the navigation extras
        })
            .then((value) => {
            // we reset the current keys and navigation extras on navigation
            // in order to avoid leaking to other navigations
            this._currentKeys = {};
            this._navigationExtras = {};
            return value;
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.7", ngImport: i0, type: LinkedQueryParamGlobalHandler, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.7", ngImport: i0, type: LinkedQueryParamGlobalHandler, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.7", ngImport: i0, type: LinkedQueryParamGlobalHandler, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: () => [] });
function linkedQueryParam(key, options) {
    if (options?.defaultValue !== undefined && options?.parse) {
        throw new Error('linkedQueryParam: You cannot have both defaultValue and parse at the same time!');
    }
    const injector = assertInjector(linkedQueryParam, options?.injector);
    return runInInjectionContext(injector, () => {
        const route = inject(ActivatedRoute);
        const globalHandler = inject(LinkedQueryParamGlobalHandler);
        const config = inject(_LINKED_QUERY_PARAM_CONFIG_TOKEN);
        /**
         * Parses a parameter value based on provided configuration.
         * @param params - An object containing parameters.
         * @returns The parsed parameter value.
         */
        const parseParamValue = (params) => {
            // Get the value from the params object.
            const value = params[key] ?? null;
            // If a parsing function is provided in the config, use it to parse the value.
            if (options?.parse) {
                return options.parse(value);
            }
            // If the value is undefined or null and a default value is provided, return the default value.
            if ((value === undefined || value === null) &&
                options?.defaultValue !== undefined) {
                return options.defaultValue;
            }
            // Otherwise, return the original value or the parsed value (if it was parsed).
            return value;
        };
        // create a signal that is updated whenever the query param changes
        const queryParamValue = toSignal(route.queryParams.pipe(distinctUntilKeyChanged(key), // skip if no changes on same key
        map((x) => parseParamValue(x))), { initialValue: parseParamValue(route.snapshot.queryParams) });
        const source = signal(queryParamValue());
        const originalSet = source.set;
        explicitEffect([queryParamValue], ([value]) => {
            // update the source signal whenever the query param changes
            originalSet(value);
        });
        const set = (value) => {
            // first we check if the value is undefined or null so we can set the default value instead
            if ((value === undefined || value === null) &&
                options?.defaultValue !== undefined) {
                value = options.defaultValue;
            }
            // we first set the initial value so it synchronous (same as a normal signal)
            originalSet(value);
            // when the source signal changes, update the query param
            // store the new value in the current keys so that we can coalesce the navigation
            let valueToBeSet = value;
            if (options?.stringify) {
                valueToBeSet = options.stringify(value);
            }
            else if (value === undefined || value === null) {
                valueToBeSet = null;
            }
            else {
                valueToBeSet = typeof value === 'string' ? value : String(value);
            }
            globalHandler.setParamKeyValue(key, valueToBeSet);
            globalHandler.setCurrentNavigationExtras({
                ...defaultConfig,
                ...config,
                ...(options ?? {}),
            });
            // schedule the navigation event (multiple synchronous navigations will be coalesced)
            // this will also reset the current keys and navigation extras after the navigation
            globalHandler.scheduleNavigation();
        };
        const update = (fn) => set(fn(source()));
        return Object.assign(source, { set, update });
    });
}
function paramToNumber(config = { defaultValue: null }) {
    return (x) => {
        if (x === undefined || x === null)
            return config.defaultValue;
        const parsed = parseInt(x, 10);
        if (Number.isNaN(parsed))
            return config.defaultValue;
        return parsed;
    };
}
function paramToBoolean(config = {
    defaultValue: null,
}) {
    return (x) => x === undefined || x === null ? config.defaultValue : x === 'true';
}

/**
 * Generated bundle index. Do not edit.
 */

export { LinkedQueryParamGlobalHandler, linkedQueryParam, paramToBoolean, paramToNumber, provideLinkedQueryParamConfig };
//# sourceMappingURL=ngxtension-linked-query-param.mjs.map
