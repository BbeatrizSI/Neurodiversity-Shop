import { computed, runInInjectionContext, signal, } from '@angular/core';
import { assertInjector } from 'ngxtension/assert-injector';
import { explicitEffect } from 'ngxtension/explicit-effect';
/**
 * Creates a history record with the current timestamp.
 * @param value The value to store in the history record.
 * @returns A SignalHistoryRecord object.
 */
function createHistoryRecord(value) {
    return { value, timestamp: Date.now() };
}
/**
 * Enhances a writable signal with undo/redo history functionality.
 *
 * @param source The writable signal to track.
 * @param options Configuration options for the history.
 * @returns An object with `history`, `undo`, `redo`, `canUndo`, and `canRedo` properties.
 */
export function signalHistory(source, options) {
    const injector = assertInjector(signalHistory, options?.injector);
    return runInInjectionContext(injector, () => {
        const capacity = options?.capacity ?? 100; // Default capacity is 100 records
        // Initialize the undo and redo stacks as signals
        const undoStack = signal([]);
        const redoStack = signal([]);
        // Initialize with the current value of the source signal.
        // This ensures that the history always starts with the initial value.
        const initialRecord = createHistoryRecord(source());
        undoStack.set([initialRecord]);
        // Computed signal to provide the history of changes
        const history = computed(() => [...undoStack()]);
        // Computed signals to indicate if undo/redo actions are available
        const canUndo = computed(() => undoStack().length > 1); // Can undo if there's more than just the initial state
        const canRedo = computed(() => redoStack().length > 0); // Can redo if there's more than just the initial state
        // Use explicitEffect to track changes to the source signal
        explicitEffect([source], ([value]) => {
            const lastValue = undoStack()[undoStack().length - 1]?.value;
            // skip if the value is the same as the last value
            if (value === lastValue)
                return;
            // skip if the value should not be recorded
            if (options?.shouldRecord && !options?.shouldRecord(value, lastValue))
                return;
            const newRecord = createHistoryRecord(value);
            // Update the undo stack with the new record
            undoStack.update((stack) => {
                const newStack = [...stack, newRecord];
                return capacity ? newStack.slice(-capacity) : newStack; // Apply capacity limit if provided
            });
            // Clear the redo stack when a new change is made,
            // because a new change invalidates the redo stack.
            redoStack.set([]);
        }, { defer: true, injector: options?.injector });
        /**
         * Undo the last change to the source signal.
         */
        const undo = () => {
            if (undoStack().length > 1) {
                // Prevent undoing the initial state
                // Get the last record from the undo stack
                const currentRecord = undoStack()[undoStack().length - 1];
                // Remove the last record from the undo stack
                undoStack.update((stack) => stack.slice(0, -1));
                // Add the current record to the redo stack
                redoStack.update((stack) => [currentRecord, ...stack]);
                const previousRecord = undoStack()[undoStack().length - 1];
                // Set the source signal to the previous value
                source.set(previousRecord.value);
            }
        };
        /**
         * Redo the last undone change to the source signal.
         */
        const redo = () => {
            if (redoStack().length) {
                // Get the first record from the redo stack as we want to remove it
                const nextRecord = redoStack()[0];
                // Remove the first record from the redo stack
                redoStack.update((stack) => stack.slice(1));
                // Add the next record to the undo stack
                undoStack.update((stack) => [...stack, nextRecord]);
                // Set the source signal to the next value
                source.set(nextRecord.value);
            }
        };
        /**
         * Reset the history to the current state.
         */
        const reset = () => {
            const currentRecord = undoStack()[undoStack().length - 1];
            undoStack.set([currentRecord]);
            redoStack.set([]);
        };
        /**
         * Clear the history. This will remove all history records.
         */
        const clear = () => {
            undoStack.set([]);
            redoStack.set([]);
        };
        // Return the history, undo/redo/reset/clear functions, and canUndo/canRedo signals
        return {
            history,
            undo,
            redo,
            reset,
            clear,
            canUndo,
            canRedo,
        };
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2lnbmFsLWhpc3RvcnkuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9saWJzL25neHRlbnNpb24vc2lnbmFsLWhpc3Rvcnkvc3JjL3NpZ25hbC1oaXN0b3J5LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDTixRQUFRLEVBRVIscUJBQXFCLEVBRXJCLE1BQU0sR0FFTixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sNEJBQTRCLENBQUM7QUFDNUQsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLDRCQUE0QixDQUFDO0FBTzVEOzs7O0dBSUc7QUFDSCxTQUFTLG1CQUFtQixDQUFJLEtBQVE7SUFDdkMsT0FBTyxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsSUFBSSxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUM7QUFDekMsQ0FBQztBQUVEOzs7Ozs7R0FNRztBQUNILE1BQU0sVUFBVSxhQUFhLENBQzVCLE1BQXlCLEVBQ3pCLE9Ba0JDO0lBK0JELE1BQU0sUUFBUSxHQUFHLGNBQWMsQ0FBQyxhQUFhLEVBQUUsT0FBTyxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBQ2xFLE9BQU8scUJBQXFCLENBQUMsUUFBUSxFQUFFLEdBQUcsRUFBRTtRQUMzQyxNQUFNLFFBQVEsR0FBRyxPQUFPLEVBQUUsUUFBUSxJQUFJLEdBQUcsQ0FBQyxDQUFDLGtDQUFrQztRQUU3RSxpREFBaUQ7UUFDakQsTUFBTSxTQUFTLEdBQUcsTUFBTSxDQUEyQixFQUFFLENBQUMsQ0FBQztRQUN2RCxNQUFNLFNBQVMsR0FBRyxNQUFNLENBQTJCLEVBQUUsQ0FBQyxDQUFDO1FBRXZELDBEQUEwRDtRQUMxRCxzRUFBc0U7UUFDdEUsTUFBTSxhQUFhLEdBQUcsbUJBQW1CLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQztRQUNwRCxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQztRQUUv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QUE4QztnQkFDOUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUU1Qyx3Q0FBd0M7Z0JBQ3hDLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLENBQUMsR0FBRyxLQUFLLEVBQUUsVUFBVSxDQUFDLENBQUMsQ0FBQztnQkFFcEQsMENBQTBDO2dCQUMxQyxNQUFNLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUM5QixDQUFDO1FBQ0YsQ0FBQyxDQUFDO1FBRUY7O1dBRUc7UUFDSCxNQUFNLEtBQUssR0FBRyxHQUFHLEVBQUU7WUFDbEIsTUFBTSxhQUFhLEdBQUcsU0FBUyxFQUFFLENBQUMsU0FBUyxFQUFFLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQzFELFNBQVMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDO1lBQy9CLFNBQVMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDbkIsQ0FBQyxDQUFDO1FBRUY7O1dBRUc7UUFDSCxNQUFNLEtBQUssR0FBRyxHQUFHLEVBQUU7WUFDbEIsU0FBUyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUNsQixTQUFTLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ25CLENBQUMsQ0FBQztRQUVGLG1GQUFtRjtRQUNuRixPQUFPO1lBQ04sT0FBTztZQUNQLElBQUk7WUFDSixJQUFJO1lBQ0osS0FBSztZQUNMLEtBQUs7WUFDTCxPQUFPO1lBQ1AsT0FBTztTQUNQLENBQUM7SUFDSCxDQUFDLENBQUMsQ0FBQztBQUNKLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuXHRjb21wdXRlZCxcblx0SW5qZWN0b3IsXG5cdHJ1bkluSW5qZWN0aW9uQ29udGV4dCxcblx0U2lnbmFsLFxuXHRzaWduYWwsXG5cdFdyaXRhYmxlU2lnbmFsLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGFzc2VydEluamVjdG9yIH0gZnJvbSAnbmd4dGVuc2lvbi9hc3NlcnQtaW5qZWN0b3InO1xuaW1wb3J0IHsgZXhwbGljaXRFZmZlY3QgfSBmcm9tICduZ3h0ZW5zaW9uL2V4cGxpY2l0LWVmZmVjdCc7XG5cbmludGVyZmFjZSBTaWduYWxIaXN0b3J5UmVjb3JkPFQ+IHtcblx0dmFsdWU6IFQ7XG5cdHRpbWVzdGFtcDogbnVtYmVyO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBoaXN0b3J5IHJlY29yZCB3aXRoIHRoZSBjdXJyZW50IHRpbWVzdGFtcC5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gc3RvcmUgaW4gdGhlIGhpc3RvcnkgcmVjb3JkLlxuICogQHJldHVybnMgQSBTaWduYWxIaXN0b3J5UmVjb3JkIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSGlzdG9yeVJlY29yZDxUPih2YWx1ZTogVCk6IFNpZ25hbEhpc3RvcnlSZWNvcmQ8VD4ge1xuXHRyZXR1cm4geyB2YWx1ZSwgdGltZXN0YW1wOiBEYXRlLm5vdygpIH07XG59XG5cbi8qKlxuICogRW5oYW5jZXMgYSB3cml0YWJsZSBzaWduYWwgd2l0aCB1bmRvL3JlZG8gaGlzdG9yeSBmdW5jdGlvbmFsaXR5LlxuICpcbiAqIEBwYXJhbSBzb3VyY2UgVGhlIHdyaXRhYmxlIHNpZ25hbCB0byB0cmFjay5cbiAqIEBwYXJhbSBvcHRpb25zIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIGhpc3RvcnkuXG4gKiBAcmV0dXJucyBBbiBvYmplY3Qgd2l0aCBgaGlzdG9yeWAsIGB1bmRvYCwgYHJlZG9gLCBgY2FuVW5kb2AsIGFuZCBgY2FuUmVkb2AgcHJvcGVydGllcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNpZ25hbEhpc3Rvcnk8VD4oXG5cdHNvdXJjZTogV3JpdGFibGVTaWduYWw8VD4sXG5cdG9wdGlvbnM/OiB7XG5cdFx0LyoqXG5cdFx0ICogVGhlIG1heGltdW0gbnVtYmVyIG9mIGhpc3RvcnkgcmVjb3JkcyB0byBzdG9yZS5cblx0XHQgKiBAZGVmYXVsdCAxMDBcblx0XHQgKi9cblx0XHRjYXBhY2l0eT86IG51bWJlcjtcblxuXHRcdC8qKlxuXHRcdCAqIEEgZnVuY3Rpb24gdGhhdCBkZXRlcm1pbmVzIHdoZXRoZXIgYSB2YWx1ZSBzaG91bGQgYmUgcmVjb3JkZWQgaW4gdGhlIGhpc3RvcnkuXG5cdFx0ICogQnkgZGVmYXVsdCwgYWxsIHZhbHVlcyBhcmUgcmVjb3JkZWQuXG5cdFx0ICovXG5cdFx0c2hvdWxkUmVjb3JkPzogKHZhbHVlOiBULCBvbGRWYWx1ZTogVCkgPT4gYm9vbGVhbjtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBpbmplY3RvciB0byB1c2UgZm9yIHRoZSBlZmZlY3QuXG5cdFx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXG5cdFx0ICovXG5cdFx0aW5qZWN0b3I/OiBJbmplY3Rvcjtcblx0fSxcbik6IHtcblx0LyoqXG5cdCAqIFRoZSBoaXN0b3J5IG9mIGNoYW5nZXMgdG8gdGhlIHNvdXJjZSBzaWduYWwuXG5cdCAqL1xuXHRoaXN0b3J5OiBTaWduYWw8U2lnbmFsSGlzdG9yeVJlY29yZDxUPltdPjtcblx0LyoqXG5cdCAqIFVuZG8gdGhlIGxhc3QgY2hhbmdlIHRvIHRoZSBzb3VyY2Ugc2lnbmFsLlxuXHQgKi9cblx0dW5kbzogKCkgPT4gdm9pZDtcblx0LyoqXG5cdCAqIFJlZG8gdGhlIGxhc3QgdW5kb25lIGNoYW5nZSB0byB0aGUgc291cmNlIHNpZ25hbC5cblx0ICovXG5cdHJlZG86ICgpID0+IHZvaWQ7XG5cdC8qKlxuXHQgKiBSZXNldCB0aGUgaGlzdG9yeSB0byB0aGUgY3VycmVudCBzdGF0ZS5cblx0ICovXG5cdHJlc2V0OiAoKSA9PiB2b2lkO1xuXHQvKipcblx0ICogQ2xlYXIgdGhlIGhpc3RvcnkuIFRoaXMgd2lsbCByZW1vdmUgYWxsIGhpc3RvcnkgcmVjb3Jkcy5cblx0ICovXG5cdGNsZWFyOiAoKSA9PiB2b2lkO1xuXHQvKipcblx0ICogQSBzaWduYWwgaW5kaWNhdGluZyBpZiB1bmRvIGlzIHBvc3NpYmxlLlxuXHQgKi9cblx0Y2FuVW5kbzogU2lnbmFsPGJvb2xlYW4+O1xuXHQvKipcblx0ICogQSBzaWduYWwgaW5kaWNhdGluZyBpZiByZWRvIGlzIHBvc3NpYmxlLlxuXHQgKi9cblx0Y2FuUmVkbzogU2lnbmFsPGJvb2xlYW4+O1xufSB7XG5cdGNvbnN0IGluamVjdG9yID0gYXNzZXJ0SW5qZWN0b3Ioc2lnbmFsSGlzdG9yeSwgb3B0aW9ucz8uaW5qZWN0b3IpO1xuXHRyZXR1cm4gcnVuSW5JbmplY3Rpb25Db250ZXh0KGluamVjdG9yLCAoKSA9PiB7XG5cdFx0Y29uc3QgY2FwYWNpdHkgPSBvcHRpb25zPy5jYXBhY2l0eSA/PyAxMDA7IC8vIERlZmF1bHQgY2FwYWNpdHkgaXMgMTAwIHJlY29yZHNcblxuXHRcdC8vIEluaXRpYWxpemUgdGhlIHVuZG8gYW5kIHJlZG8gc3RhY2tzIGFzIHNpZ25hbHNcblx0XHRjb25zdCB1bmRvU3RhY2sgPSBzaWduYWw8U2lnbmFsSGlzdG9yeVJlY29yZDxUPltdPihbXSk7XG5cdFx0Y29uc3QgcmVkb1N0YWNrID0gc2lnbmFsPFNpZ25hbEhpc3RvcnlSZWNvcmQ8VD5bXT4oW10pO1xuXG5cdFx0Ly8gSW5pdGlhbGl6ZSB3aXRoIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBzb3VyY2Ugc2lnbmFsLlxuXHRcdC8vIFRoaXMgZW5zdXJlcyB0aGF0IHRoZSBoaXN0b3J5IGFsd2F5cyBzdGFydHMgd2l0aCB0aGUgaW5pdGlhbCB2YWx1ZS5cblx0XHRjb25zdCBpbml0aWFsUmVjb3JkID0gY3JlYXRlSGlzdG9yeVJlY29yZChzb3VyY2UoKSk7XG5cdFx0dW5kb1N0YWNrLnNldChbaW5pdGlhbFJlY29yZF0pO1xuXG5cdFx0Ly8gQ29tcHV0ZWQgc2lnbmFsIHRvIHByb3ZpZGUgdGhlIGhpc3Rvcnkgb2YgY2hhbmdlc1xuXHRcdGNvbnN0IGhpc3RvcnkgPSBjb21wdXRlZCgoKSA9PiBbLi4udW5kb1N0YWNrKCldKTtcblxuXHRcdC8vIENvbXB1dGVkIHNpZ25hbHMgdG8gaW5kaWNhdGUgaWYgdW5kby9yZWRvIGFjdGlvbnMgYXJlIGF2YWlsYWJsZVxuXHRcdGNvbnN0IGNhblVuZG8gPSBjb21wdXRlZCgoKSA9PiB1bmRvU3RhY2soKS5sZW5ndGggPiAxKTsgLy8gQ2FuIHVuZG8gaWYgdGhlcmUncyBtb3JlIHRoYW4ganVzdCB0aGUgaW5pdGlhbCBzdGF0ZVxuXHRcdGNvbnN0IGNhblJlZG8gPSBjb21wdXRlZCgoKSA9PiByZWRvU3RhY2soKS5sZW5ndGggPiAwKTsgLy8gQ2FuIHJlZG8gaWYgdGhlcmUncyBtb3JlIHRoYW4ganVzdCB0aGUgaW5pdGlhbCBzdGF0ZVxuXG5cdFx0Ly8gVXNlIGV4cGxpY2l0RWZmZWN0IHRvIHRyYWNrIGNoYW5nZXMgdG8gdGhlIHNvdXJjZSBzaWduYWxcblx0XHRleHBsaWNpdEVmZmVjdChcblx0XHRcdFtzb3VyY2VdLFxuXHRcdFx0KFt2YWx1ZV0pID0+IHtcblx0XHRcdFx0Y29uc3QgbGFzdFZhbHVlID0gdW5kb1N0YWNrKClbdW5kb1N0YWNrKCkubGVuZ3RoIC0gMV0/LnZhbHVlO1xuXG5cdFx0XHRcdC8vIHNraXAgaWYgdGhlIHZhbHVlIGlzIHRoZSBzYW1lIGFzIHRoZSBsYXN0IHZhbHVlXG5cdFx0XHRcdGlmICh2YWx1ZSA9PT0gbGFzdFZhbHVlKSByZXR1cm47XG5cblx0XHRcdFx0Ly8gc2tpcCBpZiB0aGUgdmFsdWUgc2hvdWxkIG5vdCBiZSByZWNvcmRlZFxuXHRcdFx0XHRpZiAob3B0aW9ucz8uc2hvdWxkUmVjb3JkICYmICFvcHRpb25zPy5zaG91bGRSZWNvcmQodmFsdWUsIGxhc3RWYWx1ZSkpXG5cdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdGNvbnN0IG5ld1JlY29yZCA9IGNyZWF0ZUhpc3RvcnlSZWNvcmQodmFsdWUpO1xuXG5cdFx0XHRcdC8vIFVwZGF0ZSB0aGUgdW5kbyBzdGFjayB3aXRoIHRoZSBuZXcgcmVjb3JkXG5cdFx0XHRcdHVuZG9TdGFjay51cGRhdGUoKHN0YWNrKSA9PiB7XG5cdFx0XHRcdFx0Y29uc3QgbmV3U3RhY2sgPSBbLi4uc3RhY2ssIG5ld1JlY29yZF07XG5cdFx0XHRcdFx0cmV0dXJuIGNhcGFjaXR5ID8gbmV3U3RhY2suc2xpY2UoLWNhcGFjaXR5KSA6IG5ld1N0YWNrOyAvLyBBcHBseSBjYXBhY2l0eSBsaW1pdCBpZiBwcm92aWRlZFxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHQvLyBDbGVhciB0aGUgcmVkbyBzdGFjayB3aGVuIGEgbmV3IGNoYW5nZSBpcyBtYWRlLFxuXHRcdFx0XHQvLyBiZWNhdXNlIGEgbmV3IGNoYW5nZSBpbnZhbGlkYXRlcyB0aGUgcmVkbyBzdGFjay5cblx0XHRcdFx0cmVkb1N0YWNrLnNldChbXSk7XG5cdFx0XHR9LFxuXHRcdFx0eyBkZWZlcjogdHJ1ZSwgaW5qZWN0b3I6IG9wdGlvbnM/LmluamVjdG9yIH0sXG5cdFx0KTtcblxuXHRcdC8qKlxuXHRcdCAqIFVuZG8gdGhlIGxhc3QgY2hhbmdlIHRvIHRoZSBzb3VyY2Ugc2lnbmFsLlxuXHRcdCAqL1xuXHRcdGNvbnN0IHVuZG8gPSAoKSA9PiB7XG5cdFx0XHRpZiAodW5kb1N0YWNrKCkubGVuZ3RoID4gMSkge1xuXHRcdFx0XHQvLyBQcmV2ZW50IHVuZG9pbmcgdGhlIGluaXRpYWwgc3RhdGVcblx0XHRcdFx0Ly8gR2V0IHRoZSBsYXN0IHJlY29yZCBmcm9tIHRoZSB1bmRvIHN0YWNrXG5cdFx0XHRcdGNvbnN0IGN1cnJlbnRSZWNvcmQgPSB1bmRvU3RhY2soKVt1bmRvU3RhY2soKS5sZW5ndGggLSAxXTtcblxuXHRcdFx0XHQvLyBSZW1vdmUgdGhlIGxhc3QgcmVjb3JkIGZyb20gdGhlIHVuZG8gc3RhY2tcblx0XHRcdFx0dW5kb1N0YWNrLnVwZGF0ZSgoc3RhY2spID0+IHN0YWNrLnNsaWNlKDAsIC0xKSk7XG5cblx0XHRcdFx0Ly8gQWRkIHRoZSBjdXJyZW50IHJlY29yZCB0byB0aGUgcmVkbyBzdGFja1xuXHRcdFx0XHRyZWRvU3RhY2sudXBkYXRlKChzdGFjaykgPT4gW2N1cnJlbnRSZWNvcmQsIC4uLnN0YWNrXSk7XG5cblx0XHRcdFx0Y29uc3QgcHJldmlvdXNSZWNvcmQgPSB1bmRvU3RhY2soKVt1bmRvU3RhY2soKS5sZW5ndGggLSAxXTtcblxuXHRcdFx0XHQvLyBTZXQgdGhlIHNvdXJjZSBzaWduYWwgdG8gdGhlIHByZXZpb3VzIHZhbHVlXG5cdFx0XHRcdHNvdXJjZS5zZXQocHJldmlvdXNSZWNvcmQudmFsdWUpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBSZWRvIHRoZSBsYXN0IHVuZG9uZSBjaGFuZ2UgdG8gdGhlIHNvdXJjZSBzaWduYWwuXG5cdFx0ICovXG5cdFx0Y29uc3QgcmVkbyA9ICgpID0+IHtcblx0XHRcdGlmIChyZWRvU3RhY2soKS5sZW5ndGgpIHtcblx0XHRcdFx0Ly8gR2V0IHRoZSBmaXJzdCByZWNvcmQgZnJvbSB0aGUgcmVkbyBzdGFjayBhcyB3ZSB3YW50IHRvIHJlbW92ZSBpdFxuXHRcdFx0XHRjb25zdCBuZXh0UmVjb3JkID0gcmVkb1N0YWNrKClbMF07XG5cblx0XHRcdFx0Ly8gUmVtb3ZlIHRoZSBmaXJzdCByZWNvcmQgZnJvbSB0aGUgcmVkbyBzdGFja1xuXHRcdFx0XHRyZWRvU3RhY2sudXBkYXRlKChzdGFjaykgPT4gc3RhY2suc2xpY2UoMSkpO1xuXG5cdFx0XHRcdC8vIEFkZCB0aGUgbmV4dCByZWNvcmQgdG8gdGhlIHVuZG8gc3RhY2tcblx0XHRcdFx0dW5kb1N0YWNrLnVwZGF0ZSgoc3RhY2spID0+IFsuLi5zdGFjaywgbmV4dFJlY29yZF0pO1xuXG5cdFx0XHRcdC8vIFNldCB0aGUgc291cmNlIHNpZ25hbCB0byB0aGUgbmV4dCB2YWx1ZVxuXHRcdFx0XHRzb3VyY2Uuc2V0KG5leHRSZWNvcmQudmFsdWUpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBSZXNldCB0aGUgaGlzdG9yeSB0byB0aGUgY3VycmVudCBzdGF0ZS5cblx0XHQgKi9cblx0XHRjb25zdCByZXNldCA9ICgpID0+IHtcblx0XHRcdGNvbnN0IGN1cnJlbnRSZWNvcmQgPSB1bmRvU3RhY2soKVt1bmRvU3RhY2soKS5sZW5ndGggLSAxXTtcblx0XHRcdHVuZG9TdGFjay5zZXQoW2N1cnJlbnRSZWNvcmRdKTtcblx0XHRcdHJlZG9TdGFjay5zZXQoW10pO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBDbGVhciB0aGUgaGlzdG9yeS4gVGhpcyB3aWxsIHJlbW92ZSBhbGwgaGlzdG9yeSByZWNvcmRzLlxuXHRcdCAqL1xuXHRcdGNvbnN0IGNsZWFyID0gKCkgPT4ge1xuXHRcdFx0dW5kb1N0YWNrLnNldChbXSk7XG5cdFx0XHRyZWRvU3RhY2suc2V0KFtdKTtcblx0XHR9O1xuXG5cdFx0Ly8gUmV0dXJuIHRoZSBoaXN0b3J5LCB1bmRvL3JlZG8vcmVzZXQvY2xlYXIgZnVuY3Rpb25zLCBhbmQgY2FuVW5kby9jYW5SZWRvIHNpZ25hbHNcblx0XHRyZXR1cm4ge1xuXHRcdFx0aGlzdG9yeSxcblx0XHRcdHVuZG8sXG5cdFx0XHRyZWRvLFxuXHRcdFx0cmVzZXQsXG5cdFx0XHRjbGVhcixcblx0XHRcdGNhblVuZG8sXG5cdFx0XHRjYW5SZWRvLFxuXHRcdH07XG5cdH0pO1xufVxuIl19